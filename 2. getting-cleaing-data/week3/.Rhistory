if(class(y)!="matrix") {
message("Error: Please feed the matrix to the function.",
"You were trying to feed a ... ", class(y), " instead of a matrix")
return()
}
x <<- y
inv <<- NULL
}
get <- function() x
setinv <- function(inverse) inv <<- inverse
getinv <- function() inv
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
## cacheSolve() calculates the inversed matrix of a special "matrix" created by makeCacheMatrix()
## If matrix is noninvertable then cacheSolve() will return an error.
## Also matrix inversion can be appied only to square matrixes.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getinv()
if (!is.null(inv)) {
message("Getting cached inverted matrix")
return(inv)
}
mat <- x$get()
inv <- solve(mat, ...)
x$setinv(inv)
inv
}
## Function makes special "matrix" object. There is a matrix-type check at the beginning.
## If an argument is not a matrix function will return an error.
## MakeCacheMatris is a list of functions that
## 1. get value of the matrix
## 2. set value of the matrix
## 3. get the inversed matrix
## 4. set the inversed matrix
## To be noted: there is no check if matrix is singular (therefore noninvertable).
## So matrix should be invertable to use cacheSolve()
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
if(class(x)!="matrix") {
message("Error: Please feed the matrix to the function."
"You were trying to feed a ", class(x), " instead of a matrix")
return()
}
set <- function(y) {
if(class(y)!="matrix") {
message("Error: Please feed the matrix to the function.",
"You were trying to feed a ... ", class(y), " instead of a matrix")
return()
}
x <<- y
inv <<- NULL
}
get <- function() x
setinv <- function(inverse) inv <<- inverse
getinv <- function() inv
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
## cacheSolve() calculates the inversed matrix of a special "matrix" created by makeCacheMatrix()
## If matrix is noninvertable then cacheSolve() will return an error.
## Also matrix inversion can be appied only to square matrixes.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getinv()
if (!is.null(inv)) {
message("Getting cached inverted matrix")
return(inv)
}
mat <- x$get()
inv <- solve(mat, ...)
x$setinv(inv)
inv
}
mat <- makeCacheMatrix()
## Function makes special "matrix" object. There is a matrix-type check at the beginning.
## If an argument is not a matrix function will return an error.
## MakeCacheMatris is a list of functions that
## 1. get value of the matrix
## 2. set value of the matrix
## 3. get the inversed matrix
## 4. set the inversed matrix
## To be noted: there is no check if matrix is singular (therefore noninvertable).
## So matrix should be invertable to use cacheSolve()
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
if(class(x)!="matrix") {
message("Error: Please feed the matrix to the function."
"You were trying to feed a ", class(x), " instead of a matrix")
return()
}
set <- function(y) {
if(class(y)!="matrix") {
message("Error: Please feed the matrix to the function.",
"You were trying to feed a ... ", class(y), " instead of a matrix")
return()
}
x <<- y
inv <<- NULL
}
get <- function() x
setinv <- function(inverse) inv <<- inverse
getinv <- function() inv
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
## cacheSolve() calculates the inversed matrix of a special "matrix" created by makeCacheMatrix()
## If matrix is noninvertable then cacheSolve() will return an error.
## Also matrix inversion can be appied only to square matrixes.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getinv()
if (!is.null(inv)) {
message("Getting cached inverted matrix")
return(inv)
}
mat <- x$get()
inv <- solve(mat, ...)
x$setinv(inv)
inv
}
## Function makes special "matrix" object. There is a matrix-type check at the beginning.
## If an argument is not a matrix function will return an error.
## MakeCacheMatris is a list of functions that
## 1. get value of the matrix
## 2. set value of the matrix
## 3. get the inversed matrix
## 4. set the inversed matrix
## To be noted: there is no check if matrix is singular (therefore noninvertable).
## So matrix should be invertable to use cacheSolve()
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
if(class(x)!="matrix") {
message("Error: Please feed the matrix to the function."
"You were trying to feed a ", class(x), " instead of a matrix")
return()
}
set <- function(y) {
if(class(y)!="matrix") {
message("Error: Please feed the matrix to the function.",
"You were trying to feed a ... ", class(y), " instead of a matrix")
return()
}
x <<- y
inv <<- NULL
}
get <- function() x
setinv <- function(inverse) inv <<- inverse
getinv <- function() inv
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
## cacheSolve() calculates the inversed matrix of a special "matrix" created by makeCacheMatrix()
## If matrix is noninvertable then cacheSolve() will return an error.
## Also matrix inversion can be appied only to square matrixes.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getinv()
if (!is.null(inv)) {
message("Getting cached inverted matrix")
return(inv)
}
mat <- x$get()
inv <- solve(mat, ...)
x$setinv(inv)
inv
}
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
if(class(x)!="matrix") {
message("Error: Please feed the matrix to the function."
"You were trying to feed a ", class(x), " instead of a matrix")
return()
}
set <- function(y) {
if(class(y)!="matrix") {
message("Error: Please feed the matrix to the function.",
"You were trying to feed a ... ", class(y), " instead of a matrix")
return()
}
x <<- y
inv <<- NULL
}
get <- function() x
setinv <- function(inverse) inv <<- inverse
getinv <- function() inv
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
if(class(x)!="matrix") {
message("Error: Please feed the matrix to the function."
"You were trying to feed a ", class(x), " instead of a matrix")
return()
}
set <- function(y) {
if(class(y)!="matrix") {
message("Error: Please feed the matrix to the function.",
"You were trying to feed a ... ", class(y), " instead of a matrix")
return()
}
x <<- y
inv <<- NULL
}
get <- function() x
setinv <- function(inverse) inv <<- inverse
getinv <- function() inv
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
if(class(x)!="matrix") {
message("Error: Please feed the matrix to the function."
"You were trying to feed a ", class(x), " instead of a matrix")
return()
}
set <- function(y) {
if(class(y)!="matrix") {
message("Error: Please feed the matrix to the function.",
"You were trying to feed a ... ", class(y), " instead of a matrix")
return()
}
x <<- y
inv <<- NULL
}
get <- function() x
setinv <- function(inverse) inv <<- inverse
getinv <- function() inv
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
if(class(x)!="matrix") {
message("Error: Please feed the matrix to the function."
"You were trying to feed a ", class(x), " instead of a matrix")
return()
}
set <- function(y) {
if(class(y)!="matrix") {
message("Error: Please feed the matrix to the function.",
"You were trying to feed a ... ", class(y), " instead of a matrix")
return()
}
x <<- y
inv <<- NULL
}
get <- function() x
setinv <- function(inverse) inv <<- inverse
getinv <- function() inv
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
if(class(x)!="matrix") {
message("Error: Please feed the matrix to the function."
"You were trying to feed a ", class(x), " instead of a matrix")
return()
}
set <- function(y) {
if(class(y)!="matrix") {
message("Error: Please feed the matrix to the function.",
"You were trying to feed a ... ", class(y), " instead of a matrix")
return()
}
x <<- y
inv <<- NULL
}
get <- function() x
setinv <- function(inverse) inv <<- inverse
getinv <- function() inv
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
testset <- read.table("./test/X_test.txt")
getwd()
setwd("C:/Users/a.titov/rprog/getting-cleaing-data/week3/wearable project/")
testset <- read.table("./test/X_test.txt")
View(testset)
str(testset)
grepl("mean", "fBodyAccJerk-meanFreq()-X")
grepl("mean1", "fBodyAccJerk-meanFreq()-X")
featurelist <- read.table("features.txt")
head(featurelist)
head(featurelist$V2)
head(grepl("mean", featurelist$V2)
)
head(grepl("mean", featurelist$V2) | grepl("std", featurelist$V2))
head(grepl("mean", featurelist$V2) | grepl("std", featurelist$V2),10)
meanstdcol <- head(grepl("mean", featurelist$V2) | grepl("std", featurelist$V2),10)
meanstdcol <- head(grepl("mean", featurelist$V2) | grepl("std", featurelist$V2),10)
meanstdcol
meanstdcol <- grepl("mean", featurelist$V2) | grepl("std", featurelist$V2)
sum(meanstdcol)
head(testset[,meanstdcol])
ncol(testset[,meanstdcol])
#testset <- read.table("./test/X_test.txt")
#trainset <- read.table("./train/X_train.txt")
#featurelist <- read.table("features.txt")
#meanstdcol <- grepl("mean", featurelist$V2) | grepl("std", featurelist$V2)
#grepl("mean", "fBodyAccJerk-meanFreq()-X")
library(data.table)
# 0. load test and training sets and the activities
# Use the course CDN instead of the original UCI zip file.
#fileUrl <- "http://archive.ics.uci.edu/ml/machine-learning-databases/00240/UCI%20HAR%20Dataset.zip"
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fprojectfiles%2FUCI%20HAR%20Dataset.zip"
download.file(fileUrl, destfile = "Dataset.zip", method = "curl")
unzip("Dataset.zip")
testData <- read.table("./UCI HAR Dataset/test/X_test.txt",header=FALSE)
testData_act <- read.table("./UCI HAR Dataset/test/y_test.txt",header=FALSE)
testData_sub <- read.table("./UCI HAR Dataset/test/subject_test.txt",header=FALSE)
trainData <- read.table("./UCI HAR Dataset/train/X_train.txt",header=FALSE)
trainData_act <- read.table("./UCI HAR Dataset/train/y_train.txt",header=FALSE)
trainData_sub <- read.table("./UCI HAR Dataset/train/subject_train.txt",header=FALSE)
# 3. Uses descriptive activity names to name the activities in the data set
activities <- read.table("./UCI HAR Dataset/activity_labels.txt",header=FALSE,colClasses="character")
testData_act$V1 <- factor(testData_act$V1,levels=activities$V1,labels=activities$V2)
trainData_act$V1 <- factor(trainData_act$V1,levels=activities$V1,labels=activities$V2)
# 4. Appropriately labels the data set with descriptive activity names
features <- read.table("./UCI HAR Dataset/features.txt",header=FALSE,colClasses="character")
colnames(testData)<-features$V2
colnames(trainData)<-features$V2
colnames(testData_act)<-c("Activity")
colnames(trainData_act)<-c("Activity")
colnames(testData_sub)<-c("Subject")
colnames(trainData_sub)<-c("Subject")
# 1. merge test and training sets into one data set, including the activities
testData<-cbind(testData,testData_act)
testData<-cbind(testData,testData_sub)
trainData<-cbind(trainData,trainData_act)
trainData<-cbind(trainData,trainData_sub)
bigData<-rbind(testData,trainData)
# 2. extract only the measurements on the mean and standard deviation for each measurement
bigData_mean<-sapply(bigData,mean,na.rm=TRUE)
bigData_sd<-sapply(bigData,sd,na.rm=TRUE)
# 5. Creates a second, independent tidy data set with the average of each variable for each activity and each subject.
DT <- data.table(bigData)
tidy<-DT[,lapply(.SD,mean),by="Activity,Subject"]
write.table(tidy,file="tidy.csv",sep=",",row.names = FALSE)
require(data.table)
install.packages("data.table")
#testset <- read.table("./test/X_test.txt")
#trainset <- read.table("./train/X_train.txt")
#featurelist <- read.table("features.txt")
#meanstdcol <- grepl("mean", featurelist$V2) | grepl("std", featurelist$V2)
#grepl("mean", "fBodyAccJerk-meanFreq()-X")
library(data.table)
# 0. load test and training sets and the activities
# Use the course CDN instead of the original UCI zip file.
#fileUrl <- "http://archive.ics.uci.edu/ml/machine-learning-databases/00240/UCI%20HAR%20Dataset.zip"
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fprojectfiles%2FUCI%20HAR%20Dataset.zip"
download.file(fileUrl, destfile = "Dataset.zip", method = "curl")
unzip("Dataset.zip")
testData <- read.table("./UCI HAR Dataset/test/X_test.txt",header=FALSE)
testData_act <- read.table("./UCI HAR Dataset/test/y_test.txt",header=FALSE)
testData_sub <- read.table("./UCI HAR Dataset/test/subject_test.txt",header=FALSE)
trainData <- read.table("./UCI HAR Dataset/train/X_train.txt",header=FALSE)
trainData_act <- read.table("./UCI HAR Dataset/train/y_train.txt",header=FALSE)
trainData_sub <- read.table("./UCI HAR Dataset/train/subject_train.txt",header=FALSE)
# 3. Uses descriptive activity names to name the activities in the data set
activities <- read.table("./UCI HAR Dataset/activity_labels.txt",header=FALSE,colClasses="character")
testData_act$V1 <- factor(testData_act$V1,levels=activities$V1,labels=activities$V2)
trainData_act$V1 <- factor(trainData_act$V1,levels=activities$V1,labels=activities$V2)
# 4. Appropriately labels the data set with descriptive activity names
features <- read.table("./UCI HAR Dataset/features.txt",header=FALSE,colClasses="character")
colnames(testData)<-features$V2
colnames(trainData)<-features$V2
colnames(testData_act)<-c("Activity")
colnames(trainData_act)<-c("Activity")
colnames(testData_sub)<-c("Subject")
colnames(trainData_sub)<-c("Subject")
# 1. merge test and training sets into one data set, including the activities
testData<-cbind(testData,testData_act)
testData<-cbind(testData,testData_sub)
trainData<-cbind(trainData,trainData_act)
trainData<-cbind(trainData,trainData_sub)
bigData<-rbind(testData,trainData)
# 2. extract only the measurements on the mean and standard deviation for each measurement
bigData_mean<-sapply(bigData,mean,na.rm=TRUE)
bigData_sd<-sapply(bigData,sd,na.rm=TRUE)
# 5. Creates a second, independent tidy data set with the average of each variable for each activity and each subject.
DT <- data.table(bigData)
tidy<-DT[,lapply(.SD,mean),by="Activity,Subject"]
write.table(tidy,file="tidy.csv",sep=",",row.names = FALSE)
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fprojectfiles%2FUCI%20HAR%20Dataset.zip"
download.file(fileUrl, destfile = "Dataset.zip", method = "curl")
unzip("Dataset.zip"
download.file(fileUrl, destfile = "Dataset.zip", method = "curl")
download.file(fileUrl, destfile = "Dataset.zip")
unzip("Dataset.zip")
testData <- read.table("./UCI HAR Dataset/test/X_test.txt",header=FALSE)
testData_act <- read.table("./UCI HAR Dataset/test/y_test.txt",header=FALSE)
testData_sub <- read.table("./UCI HAR Dataset/test/subject_test.txt",header=FALSE)
trainData <- read.table("./UCI HAR Dataset/train/X_train.txt",header=FALSE)
trainData_act <- read.table("./UCI HAR Dataset/train/y_train.txt",header=FALSE)
trainData_sub <- read.table("./UCI HAR Dataset/train/subject_train.txt",header=FALSE)
# 3. Uses descriptive activity names to name the activities in the data set
activities <- read.table("./UCI HAR Dataset/activity_labels.txt",header=FALSE,colClasses="character")
testData_act$V1 <- factor(testData_act$V1,levels=activities$V1,labels=activities$V2)
trainData_act$V1 <- factor(trainData_act$V1,levels=activities$V1,labels=activities$V2)
# 4. Appropriately labels the data set with descriptive activity names
features <- read.table("./UCI HAR Dataset/features.txt",header=FALSE,colClasses="character")
colnames(testData)<-features$V2
colnames(trainData)<-features$V2
colnames(testData_act)<-c("Activity")
colnames(trainData_act)<-c("Activity")
colnames(testData_sub)<-c("Subject")
colnames(trainData_sub)<-c("Subject")
# 1. merge test and training sets into one data set, including the activities
testData<-cbind(testData,testData_act)
testData<-cbind(testData,testData_sub)
trainData<-cbind(trainData,trainData_act)
trainData<-cbind(trainData,trainData_sub)
bigData<-rbind(testData,trainData)
# 2. extract only the measurements on the mean and standard deviation for each measurement
bigData_mean<-sapply(bigData,mean,na.rm=TRUE)
bigData_sd<-sapply(bigData,sd,na.rm=TRUE)
# 5. Creates a second, independent tidy data set with the average of each variable for each activity and each subject.
DT <- data.table(bigData)
tidy<-DT[,lapply(.SD,mean),by="Activity,Subject"]
write.table(tidy,file="tidy.csv",sep=",",row.names = FALSE)
head(tidy)
str(tidy)
head(tidy[,1:4])
head(tidy[,4])
head(tidy)
write.table(tidy,file="tidy.txt",sep=",",row.names = FALSE)
setwd("C:/Users/a.titov/rprog/getting-cleaing-data/week3")
library(dplyr)
fileURL <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FGDP.csv"
fileURLedu <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FEDSTATS_Country.csv"
download.file(fileURL, destfile = "GDP.csv")
download.file(fileURLedu, destfile = "GDPedu.csv")
GDP <- read.csv("GDP.csv")
GDPedu <- read.csv("GDPedu.csv")
file.remove("GDP.csv", "GDPedu.csv")
sum(GDP$X %in% GDPedu$CountryCode)
View(GDP)
sum(GDP$X %in% GDPedu$CountryCode)
GDP$X.3 <- gsub(",","",GDP$X.3)
View(GDP)
head(GDP$X.3[5:194])
arrange(head(GDP$X.3[5:194]))
as.numeric(head(GDP$X.3[5:194]))
arrange(as.numeric(head(GDP$X.3[5:194])))
sort(as.numeric(head(GDP$X.3[5:194])))
GDP$X.3 <- gsub(",","",GDP$X.3)
GDP$X.3[5:nrow(GDP)] <- as.numeric(GDP$X.3[5:nrow(GDP)])
GDP[order(GDP$X.3), ]
fileURL <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FGDP.csv"
fileURLedu <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FEDSTATS_Country.csv"
download.file(fileURL, destfile = "GDP.csv")
download.file(fileURLedu, destfile = "GDPedu.csv")
GDP <- read.csv("GDP.csv")
GDPedu <- read.csv("GDPedu.csv")
file.remove("GDP.csv", "GDPedu.csv")
GDP$X.3 <- gsub(",","",GDP$X.3)
GDP$X.3 <- gsub(" ","",GDP$X.3)
GDP$X.3[5:nrow(GDP)] <- as.numeric(GDP$X.3[5:nrow(GDP)])
GDP$X.3[44]
sort(GDP$X.3)
sort(c("11,111,2,3,33,-4"))
sort(c(11,111,2,3,33,-4))
GDP$X.3[5:nrow(GDP)] <- as.numeric(GDP$X.3[5:nrow(GDP)])
sort(c(11,111,2,3,33,-4))[4]
GDP$X.3[44]
type(GDP$X.3[44])
typeof(GDP$X.3[44])
as.numeric(GDP$X.3[44])
typeof(as.numeric(GDP$X.3[44]))
as.numeric(GDP$X.3[5:nrow(GDP)])
as.numeric(GDP$X.3[5:nrow(GDP)])[44]
GDP$X.3[5:nrow(GDP)] <- as.numeric(GDP$X.3[5:nrow(GDP)])
GDP$X.3[13]
as.numeric(GDP$X.3[5:nrow(GDP)])[13]
GDP$X.3[5:nrow(GDP)] = as.numeric(GDP$X.3[5:nrow(GDP)])
GDP$X.3[13]
typeof(GDP$X.3[13])
typeof(as.numeric(GDP$X.3[5:nrow(GDP)])[13])
GDP$X.3[13]
as.numeric(GDP$X.3[13])
GDP$X.3[13] <- as.numeric(GDP$X.3[13] )
GDP$X.3[13]
GDP$X.3[13] = as.numeric(GDP$X.3[13] )
GDP$X.3[13]
GDP$X.3[13]
GDP$X.3[13]
View(GDP)
names(GDP)
names(GDP)[3]
names(GDP)[5]
GDP[5:nrow(GDP),5] <- as.numeric(GDP$X.3[5:nrow(GDP)])
GDP$X.3[13]
head(GDP[5:nrow(GDP),5])
GDP[5:nrow(GDP),5] <- sapply(GDP$X.3[5:nrow(GDP)],as.numeric)
GDP$X.3[13]
typeof(GDP$X.3[13])
sapply(GDP$X.3[5:nrow(GDP)],as.numeric)[3]
as.numeric(GDP$X.3[5:nrow(GDP)])[3]
